package learning;import java.util.Stack;public class Profile {    /**     * 最佳时机2，动态规划解法     *     * @param args     */    public static void main(String[] args) {        int[] prices = new int[]{7, 1, 5, 3, 6, 4};        int size = prices.length;        int[] cache = new int[size + 2];        maxProfit1(prices, size - 2, cache);        print(cache);    }    public static int maxProfit1(int[] prices, int index, int[] cache) {        int length = prices.length;        int max = 0;        for (int start = index; start >= 0; start--) {            for (int end = length - 1; end >= start + 1; end--) {                if (prices[end] < prices[start]) {                    cache[start] = cache[start + 1];                    continue;                }                int pricestemp = prices[end] - prices[start] + cache[end + 1];                if (pricestemp > cache[start]) {                    cache[start] = pricestemp;                }                if (cache[start] > max) {                    max = cache[start];                }            }        }        return max;    }    /**     * 最佳时机2，递归解法     *     * @param prices     * @return     */    public static final int maxProfit(int[] prices) {        if (prices == null) {            return 0;        }        int[] cache = new int[prices.length + 1];        return maxProfit(prices, 0, cache);    }    public static final int maxProfit(int[] prices, int index, int[] cache) {        int length = prices.length;        int max = 0;        if (index > length) {            return 0;        }        if (cache[index] != 0) {            return cache[index];        }        for (int start = index; start < length; start++) {            for (int end = start + 1; end < length; end++) {                if (prices[end] < prices[start]) {                    continue;                }                int pricestemp = prices[end] - prices[start] + maxProfit(prices, end + 1, cache);                if (pricestemp > max) {                    max = pricestemp;                }            }        }        cache[index] = max;        return cache[index];    }    /**     * 最佳时机2，个人抽象的正确递归，时间复杂度高     */    public static void main1() {        int[] prices = new int[]{7, 1, 5, 3, 6, 4};        int size = prices.length;        int[] cache = new int[size + 1];        maxProfitAt(prices, 0, cache);        sort(cache);//        print(cache);    }    public static final int maxProfitAt(int[] prices, int index, int[] cache) {        int size = prices.length;        if (index >= size) {            return 0;        }        if (index == size - 2) {            if (prices[size - 2] < prices[size - 1]) {                return prices[size - 1] - prices[size - 2];            }            return 0;        }        if (cache[index] != 0) {            return cache[index];        }        int max = 0;        int maxProfit = 0;        for (int i = index + 1; i < size; i++) {            if (prices[i] < prices[index]) {                continue;            }            int temp = prices[i] - prices[index];            for (int j = i + 1; j < size + 1; j++) {                int profit = temp + maxProfitAt(prices, j, cache);                if (profit > max) {                    max = profit;                }            }        }        cache[index] = max;        return max;    }    public static final void sort(int[] cache) {        int size = cache.length;        for (int i = 0; i < size; i++) {            for (int j = 0; j < size - 1 - i; j++) {                if (cache[j] < cache[j + 1]) {                    int temp = cache[j];                    cache[j] = cache[j + 1];                    cache[j + 1] = temp;                }            }        }    }    public static final void print(int[] nums) {        int size = nums.length;        for (int i = 0; i < size; i++) {            System.out.println(nums[i]);        }    }    /**     * 最佳时机3，时间复杂度高但正确的解法     */    public int maxProfit3(int[] prices) {        int length = prices.length;        if (prices == null) {            return 0;        }        int max = 0;        int[] cache = new int[length + 2];        for (int i = 0; i < length; i++) {            for (int j = i + 1; j < length; j++) {                if (prices[j] < prices[i]) {                    continue;                }                for (int k = j + 1; k < length + 1; k++) {                    int pricesTemp = prices[j] - prices[i] + maxProfitSecond(prices, k, cache);                    if (pricesTemp > max) {                        max = pricesTemp;                    }                }            }        }        return max;    }    public final int maxProfitSecond(int[] prices, int start, int[] cache) {        if (cache[start] != 0) {            return cache[start];        }        int max = 0;        for (int i = start; i < prices.length; i++) {            if (prices[i] > prices[start]) {                int pricesTemp = prices[i] - prices[start];                if (pricesTemp > max) {                    max = pricesTemp;                }            }        }        cache[start] = max;        return max;    }}