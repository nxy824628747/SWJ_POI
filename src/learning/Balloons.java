package learning;/** * @Author Nxy * @Date 2019/11/27 16:20 * @Description leetcode 戳气球 */public class Balloons {    public static void main(String[] args) {        int[] nums1 = {3, 4, 5, 6, 7, 5, 7, 8, 5, 3, 2, 5, 3, 4, 5, 6, 7, 5, 7, 8, 5, 3, 2, 5, 3, 4, 5, 6, 7, 5, 7, 8, 5, 3, 2, 5};        int[] nums = {2, 3, 7, 9, 1, 2};        long start = System.currentTimeMillis();        start = System.currentTimeMillis();//        System.out.println(maxCoins(nums));//        System.out.println("原始回溯用时   ：   " + String.valueOf(System.currentTimeMillis() - start) + "  运算次数：" + sum3);        start = System.currentTimeMillis();        System.out.println(maxCoins4MS(nums));        System.out.println("分治用时   ：   " + String.valueOf(System.currentTimeMillis() - start) + "  运算次数：" + sum1 + "  实际运算次数：" + sum2);        start = System.currentTimeMillis();        System.out.println(maxCoins4DP(nums));        System.out.println("DP用时   ：   " + String.valueOf(System.currentTimeMillis() - start));    }    static int sum1 = 0;    static int sum2 = 0;    static int sum3 = 0;    private static int maxCoin = 0;    private static int maxCoinTemp = 0;    //原始回溯    public static int maxCoins(int[] nums) {        maxCoin = 0;        if (nums == null) {            return maxCoin;        }        int length = nums.length;        maxCoins2(nums, 0, length, 0);        return maxCoin;    }    /**     * @Author Nyr     * @Date 2019/11/30 22:24     * @Param nums:气球数组，y：递归层级，及currentLevel,length：数组长度，防止每层都计算一次，beforeCoins：之前所有层获得的金币和，即currentCoin     * @Return     * @Exception     * @Description 回溯解法     */    public static void maxCoins2(int[] nums, int y, int length, int beforeCoins) {        sum3++;        //回归条件        if (y == length) {            if (beforeCoins > maxCoin) {                maxCoin = beforeCoins;            }            return;        }        for (int i = 0; i < length; i++) {            //略过已经戳破的气球            if (nums[i] == -1) {                continue;            }            //标记已经戳破的气球            int temp = nums[i];            nums[i] = -1;            //获取上一个气球的数字            int before = i - 1;            int beforeNum = 0;            while (before > -1 && nums[before] == -1) {                before--;            }            if (before < 0) {                beforeNum = 1;            } else {                beforeNum = nums[before];            }            //获取下一个气球的数字            int next = i + 1;            int nextNum = 0;            while (next < length && nums[next] == -1) {                next++;            }            if (next > length - 1) {                nextNum = 1;            } else {                nextNum = nums[next];            }            //计算戳破当前气球的coin            int tempCoin = temp * nextNum * beforeNum;            //递归进行下一戳            maxCoins2(nums, y + 1, length, beforeCoins + tempCoin);            //回溯尝试其它戳法            nums[i] = temp;        }    }    //分治一次    public static int maxCoins3M(int[] nums) {        if (nums == null) {            return 0;        }        int length = nums.length;        for (int i = 0; i < length; i++) {            maxCoins3(nums, length, i);        }        return maxCoin;    }    //分治一次    public static void maxCoins3(int[] nums, int length, int flag) {        maxCoinTemp = 0;        maxCoins3(nums, 0, length, 0, 0, flag);        int max1 = maxCoinTemp;        maxCoinTemp = 0;        maxCoins3(nums, 0, length, 0, flag + 1, length);        int max2 = maxCoinTemp;        int maxCoinTemp2 = max1 + max2 + nums[flag];        if (maxCoinTemp2 > maxCoin) {            maxCoin = maxCoinTemp2;        }    }    //分治一次    public static void maxCoins3(int[] nums, int y, int length, int beforeCoins, int begin, int end) {        //回归条件        if (y == end) {            if (beforeCoins > maxCoinTemp) {                maxCoinTemp = beforeCoins;            }            return;        }        for (int i = begin; i < end; i++) {            //略过已经戳破的气球            if (nums[i] == -1) {                continue;            }            //标记已经戳破的气球            int temp = nums[i];            nums[i] = -1;            //获取上一个气球的数字            int before = i - 1;            int beforeNum = 0;            while (before > -1 && nums[before] == -1) {                before--;            }            if (before < 0) {                beforeNum = 1;            } else {                beforeNum = nums[before];            }            //获取下一个气球的数字            int next = i + 1;            int nextNum = 0;            while (next < length && nums[next] == -1) {                next++;            }            if (next > length - 1) {                nextNum = 1;            } else {                nextNum = nums[next];            }            //计算戳破当前气球的coin            int tempCoin = temp * nextNum * beforeNum;            //递归进行下一戳            maxCoins3(nums, y + 1, length, beforeCoins + tempCoin, begin, end);            //回溯尝试其它戳法            nums[i] = temp;        }    }    public static final int maxCoins4MS(int[] nums) {        //空数组处理        if (nums == null) {            return maxCoin;        }        //加虚拟边界        int length = nums.length;        int[] nums2 = new int[length + 2];        System.arraycopy(nums, 0, nums2, 1, length);        nums2[0] = 1;        nums2[length + 1] = 1;        length = nums2.length;        //创建缓存数组        int[][] cache = new int[length][length];        //调用分治函数        return maxCoins4M(nums2, length, cache);    }    public static int maxCoins4M(int[] nums, int length, int[][] cache) {        int max = maxCoins4(nums, length, 0, length - 1, cache);        return max;    }    /**     * @Author Nyr     * @Date 2019/12/1 0:23     * @Param nums:气球数组；length:数组长度，避免每层都计算一次；begin:开始下标；end:结束下标；cache:缓存，避免重复计算     * @Return     * @Exception     * @Description 状态转移方程 def( i, j ) = max { def( i , k ) + def( k , j )+nums[ i ][ j ][ k ] } | i<k<j 的实现     */    public static int maxCoins4(int[] nums, int length, int begin, int end, int[][] cache) {        //回归条件，问题分解到最小子问题        if (begin == end - 1) {            return 0;        }        sum1++;        //缓存，避免重复计算        if (cache[begin][end] != 0) {            return cache[begin][end];        }        sum2++;        //维护一个最大值        int max = 0;        //状态转移方程 def( i, j ) = max { def( i , k ) + def( k , j )+nums[ i ][ j ][ k ] } | i<k<j        for (int i = begin + 1; i < end; i++) {            int temp = maxCoins4(nums, length, begin, i, cache) +                    maxCoins4(nums, length, i, end, cache) + nums[begin] * nums[i] * nums[end];            if (temp > max) {                max = temp;            }        }        //缓存，避免重复计算        cache[begin][end] = max;        return max;    }    /**     * @Author Nyr     * @Date 2019/12/2 10:43     * @Param     * @Return     * @Exception     * @Description 动态规划解法     */    public static int maxCoins4DP(int[] nums) {        //避免空指针异常        if (nums == null) {            return 0;        }        //创建虚拟边界        int length = nums.length;        int[] nums2 = new int[length + 2];        System.arraycopy(nums, 0, nums2, 1, length);        nums2[0] = 1;        nums2[length + 1] = 1;        length = nums2.length;        //创建dp表        length = nums2.length;        int[][] dp = new int[length][length];        //开始dp：i为begin，j为end，k为在i、j区间划分子问题时的边界        for (int i = length - 2; i > -1; i--) {            for (int j = i + 2; j < length; j++) {                //维护一个最大值；如果i、j相邻，值为0                int max = 0;                for (int k = i + 1; k < j; k++) {                    int temp = dp[i][k] + dp[k][j] + nums2[i] * nums2[k] * nums2[j];                    if (temp > max) {                        max = temp;                    }                }                dp[i][j] = max;            }        }        return dp[0][length - 1];    }    public static void print(int[][] nums) {        int x = nums.length;        int y = nums[0].length;        for (int i = 0; i < x; i++) {            for (int j = 0; j < y; j++) {                System.out.print(nums[i][j]);                System.out.print(",");            }            System.out.println(System.lineSeparator());        }    }    public static void maxCoins5(int[] nums) {        if (nums == null) {            return;        }        int length = nums.length;        int[][] dp = new int[length][length];    }}