package learning;import com.A.D.A.I;import java.util.*;/***   @Author Nxy*   @Date 2019/12/30 14:33*   @Description leetcode 1042 不邻街植花*/public class Flowers {    /**    *   @Author Nxy    *   @Date 2019/12/30 14:34    *   @Param    *   @Return    *   @Exception    *   @Description 超时    */    public int[] gardenNoAdj(int N, int[][] paths) {        int[] result = new int[N];        int x = paths.length;        for (int i = 1; i <= N; i++) {            System.out.println("种第 "+i+" 个花园的花" );            for (int j = 1; j < 5; j++) {                if (canSet(i, j, N, paths, x, result)) {                    result[i - 1] = j;                    break;                }            }        }        return result;    }    public boolean canSet(int me, int flower, int N, int[][] path, int x, int[] result) {        boolean re = true;        for (int i = 1; i <= N; i++) {            if (me != i && isAdjoin(me, i, path, x)) {                if (flower == result[i - 1]) {                    re = false;                }            }        }        System.out.println("结果为 ：" + re);        return re;    }    public boolean isAdjoin(int me, int other, int[][] path, int x) {        for (int i = 0; i < x; i++) {            if ((path[i][0] == me && path[i][1] == other) || (path[i][0] == other && path[i][1] == me)) {                return true;            }        }        return false;    }    /**    *   @Author Nxy    *   @Date 2019/12/30 14:34    *   @Param    *   @Return    *   @Exception    *   @Description 空间换时间，通过    */    public int[] gardenNoAdj2(int N, int[][] paths) {        Map<Integer,Set<Integer>> pathsMap=new HashMap<Integer,Set<Integer>>();        for(int i=0;i<N;i++){            pathsMap.put(i,new HashSet<Integer>());        }        int x=paths.length;        for(int i=0;i<x;i++){            pathsMap.get(paths[i][1]-1).add(paths[i][0]-1);            pathsMap.get(paths[i][0]-1).add(paths[i][1]-1);        }        int[] result=new int[N];        //每个花园的颜色写入结果        for(int i=1;i<=N;i++){            //尝试每种颜色            for(int flower=1;flower<5;flower++){                int target=flower;                //当前颜色有没有被相邻的花园使用                for(Integer f:pathsMap.get(i-1)){                    if(result[f]==flower){                        target=0;                        break;                    }                }                if(target!=0){                    result[i-1]=target;                    break;                }            }        }        return result;    }    public static void main(String[] args) {        Flowers f = new Flowers();        int[][] paths = {{4, 1}, {4, 2}, {4, 3}, {2, 5}, {1, 2}, {1, 5}};        f.gardenNoAdj2(6, paths);    }}