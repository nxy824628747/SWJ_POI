package learning.sort;import java.util.ArrayList;import java.util.Arrays;import java.util.List;/** * @Author Nxy * @Date 2019/12/4 10:32 * @Description 并归排序 */public class MergeSort {    public static void main(String[] args) {        int[] nums = {1,9,0,7,6,8,4,3,6,2,6,8,1,5,3,5,7,9,7,5};        int length = nums.length;        mergeSort(nums, 0, length - 1);        printNums(nums);    }    /**     * @Author Nxy     * @Date 2019/12/4 10:59     * @Param     * @Return     * @Exception     * @Description 将begin、end间的数组分解为两个子序列并回归排序     */    public static void mergeSort(int[] nums, int begin, int end) {        int length = nums.length;        //回归条件，子序列长度为一时返回        if (begin == end) {            return;        }        //序列中点        int mid = (begin + end) / 2;        //排序左边子序列        mergeSort(nums, begin, mid);        //排序右边子序列        mergeSort(nums, mid + 1, end);        //并归已排序的左右子序列        merge(nums, begin, mid, end);    }    /**     * @Author Nxy     * @Date 2019/12/4 10:59     * @Param     * @Return     * @Exception     * @Description 并归  begin--mid  与  mid+1--end  两个子序列     */    public static void merge(int[] nums, int begin, int mid, int end) {        //临时数组大小        int length = end - begin + 1;        int[] temp = new int[length];        //临时数组将要填充的位置指针        int i = 0;        //左子序列将要拿出的位置指针        int left = begin;        //右子序列将要拿出的位置指针        int right = mid + 1;        while (i < length) {            //一个子序列为空，将另一个子序列余下的元素放入临时数组            if (left == mid + 1) {                System.arraycopy(nums, right, temp, i, end - right + 1);                break;            }            if (right == end + 1) {                System.arraycopy(nums, left, temp, i, mid - left + 1);                break;            }            //选择较小的元素放入临时数组            if (nums[left] >= nums[right]) {                temp[i] = nums[right];                right++;                i++;            } else {                temp[i] = nums[left];                left++;                i++;            }        }        System.arraycopy(temp, 0, nums, begin, length);        //手动为临时数组去掉引用，方便连续的内存空间被及时回收        temp=null;    }    public static int[] mergeFalse(int[] nums) {        if (nums == null) {            return null;        }        int length = nums.length;        if (length == 1) {            return nums;        }        if (length == 2) {            if (nums[0] > nums[1]) {                int temp = nums[0];                nums[0] = nums[1];                nums[1] = temp;            }            return nums;        }        int flag = length / 2;        int[] left = new int[flag];        int[] right = new int[length - flag];        System.arraycopy(nums, 0, left, 0, flag);        System.arraycopy(nums, flag, right, 0, length - flag);        left = mergeFalse(left);        right = mergeFalse(right);        int r = 0;        int l = 0;        int i = 0;        nums = new int[length];        while (i < length) {            if (l == flag - 1) {                if (r == length - flag - 1) {                    break;                }                System.arraycopy(right, r, nums, i, length - flag - r);                break;            }            if (r == length - flag - 1) {                System.arraycopy(left, l, nums, i, flag - l);                break;            }            if (left[l] <= right[r]) {                nums[l] = left[l];                i++;                l++;                continue;            }            if (left[l] > right[r]) {                nums[i] = right[r];                r++;                i++;                continue;            }        }        printNums(nums);        return nums;    }    public static void printNums(int nums[]) {        if (nums == null) {            throw new RuntimeException("待打印数组为空！");        }        int length = nums.length;        for (int i = 0; i < length; i++) {            System.out.print(nums[i] + " , ");        }        System.out.println(System.lineSeparator());    }}