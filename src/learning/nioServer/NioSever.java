package learning.nioServer;import learning.nioServer.handler.MessageHandler;import learning.nioServer.register.ReciveRegister;import java.io.IOException;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.CharBuffer;import java.nio.channels.SelectionKey;import java.nio.channels.Selector;import java.nio.channels.ServerSocketChannel;import java.nio.channels.SocketChannel;import java.nio.charset.Charset;import java.nio.charset.CharsetDecoder;import java.nio.charset.StandardCharsets;import java.util.Iterator;public class NioSever {    private ReciveRegister reciveRegister;    private int port;    public NioSever(int port, ReciveRegister reciveRegister) {        this.reciveRegister = reciveRegister;        this.port = port;    }    public void start() throws IOException {        if (reciveRegister == null || port == 0) {            throw new NullPointerException("缺少启动参数！");        }        Selector selector = Selector.open();        ServerSocketChannel severChannel = ServerSocketChannel.open();        severChannel.configureBlocking(false);        severChannel.bind(new InetSocketAddress(port));        System.out.println("Server start!");        severChannel.register(selector, SelectionKey.OP_ACCEPT);        //select会阻塞，知道有就绪连接写入selectionKeys        while (!Thread.currentThread().isInterrupted()) {            if (selector.select(100) == 0) {                continue;            }            Iterator<SelectionKey> keys = selector.selectedKeys().iterator();            while (keys.hasNext()) {                //SelectionKey为select中记录的就绪请求的数据结构，其中包括了连接所属的socket及就绪的类型                SelectionKey key = keys.next();                //处理事件，不管是否可以处理完成，都删除 key。因为 soketChannel 为水平触发的，                // 未处理完成的事件删除后会被再次通知                keys.remove();                if (key.isAcceptable()) {                    SocketChannel socketChannel = severChannel.accept();                    System.out.println("与 client：" + socketChannel.getRemoteAddress() + " 建立连接！");                    socketChannel.configureBlocking(false);                    socketChannel.register(selector, SelectionKey.OP_READ);                } else if (key.isReadable()) {                    SocketChannel socketChannel = (SocketChannel) key.channel();                    try {                        reciveRegister.doRecive(socketChannel);                    } catch (Exception e) {                        e.printStackTrace();                    }                }            }        }    }}