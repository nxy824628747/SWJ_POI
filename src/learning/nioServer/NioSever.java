package learning.nioServer;import learning.nioServer.handler.MessageHandler;import learning.nioServer.handler.impl.PrintMessageHandlerImpl;import learning.nioServer.register.ReciveRegister;import learning.nioServer.register.impl.HLRegisterImpl;import java.io.IOException;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.CharBuffer;import java.nio.channels.SelectionKey;import java.nio.channels.Selector;import java.nio.channels.ServerSocketChannel;import java.nio.channels.SocketChannel;import java.nio.charset.Charset;import java.nio.charset.CharsetDecoder;import java.nio.charset.StandardCharsets;import java.util.Iterator;public class NioSever {    private int port;    private ReciveRegisterType reciveRegisterType;    public NioSever(int port, ReciveRegisterType reciveRegisterType) {        this.port = port;        this.reciveRegisterType = reciveRegisterType;    }    public void start() throws IOException {        if (port == 0) {            throw new NullPointerException("缺少启动参数！");        }        Selector selector = Selector.open();        ServerSocketChannel severChannel = ServerSocketChannel.open();        severChannel.configureBlocking(false);        severChannel.bind(new InetSocketAddress(port));        System.out.println("Server start!");        severChannel.register(selector, SelectionKey.OP_ACCEPT);        //select会阻塞，知道有就绪连接写入selectionKeys        while (!Thread.currentThread().isInterrupted()) {            if (selector.select(100) == 0) {                continue;            }            Iterator<SelectionKey> keys = selector.selectedKeys().iterator();            while (keys.hasNext()) {                //SelectionKey为select中记录的就绪请求的数据结构，其中包括了连接所属的socket及就绪的类型                SelectionKey key = keys.next();                //处理事件，不管是否可以处理完成，都删除 key。因为 soketChannel 为水平触发的，                // 未处理完成的事件删除后会被再次通知                keys.remove();                if (key.isAcceptable()) {                    SocketChannel socketChannel = severChannel.accept();                    System.out.println("与 client：" + socketChannel.getRemoteAddress() + " 建立连接！");                    socketChannel.configureBlocking(false);                    SelectionKey readKey = socketChannel.register(selector, SelectionKey.OP_READ);                    readKey.attach(getRegister());                } else if (key.isReadable()) {                    SocketChannel socketChannel = (SocketChannel) key.channel();                    try {                        ReciveRegister rec = (ReciveRegister) key.attachment();                        rec.doRecive(socketChannel);                    } catch (Exception e) {                        e.printStackTrace();                    }                }            }        }    }    //构建报文接收策略    private ReciveRegister getRegister() {        if (this.reciveRegisterType == ReciveRegisterType.HL) {            return new HLRegisterImpl(2, new PrintMessageHandlerImpl());        }        //to-do FL and other type        return null;    }    /**     * @Author Niuxy     * @Date 2020/5/29 3:47 下午     * @Description 内部枚举，报文接受方式     */    public enum ReciveRegisterType {        //报文头标识长度        HL,        //固定长度        FL    }}