package Demo;import org.apache.poi.ss.usermodel.FillPatternType;import org.apache.poi.util.SystemOutLogger;import org.apache.poi.xssf.usermodel.*;import java.awt.*;import java.io.*;import java.util.HashSet;import java.util.LinkedList;import java.util.List;import java.util.Set;/** * @Author Nxy * @Date 2019/11/13 16:13 * @Description 将 navicate 导出的表对象信息解析为excel */public class YtzzZJK {    static Set<String> greenKeys;    static Set<String> yellowKeys;    static String rn=System.lineSeparator();    public static void main(String[] args) {        String createPath = "C:\\Users\\niuxinyu\\Desktop\\建设工程规划许可证.txt";        String outPath = "C:\\Users\\niuxinyu\\Desktop\\建设工程规划许可证.xlsx";        BufferedReader reader = null;        XSSFWorkbook excel = null;        try {            StringBuilder columns = new StringBuilder();            reader = new BufferedReader(new InputStreamReader(new FileInputStream(createPath), "GBK"));            excel = new XSSFWorkbook();            XSSFSheet sheet = excel.createSheet("result");            int i = 1;            int l = 0;            String line;            init();            String[] headers = {"字段名称", "字段描述", "数据类型"};            setHeader(excel, sheet, headers);            while ((line = reader.readLine()) != null) {                l++;                System.out.println("正在处理第" + l + "行");                System.out.println(line);                LinkedList<String> ls = new LinkedList<String>();                StringBuilder sb = new StringBuilder(line);                getBetween(sb, "`", "`", ls);                getBefore(sb, "COMMENT", ls);                getBetween(sb, "'", "'", ls);                sb = null;                if (ls.size() != 3) {                    continue;                }                String keyName = ls.get(0);                String keyType = ls.get(1);                String keyComment = ls.get(2);                XSSFRow rowi = sheet.createRow(i);                i++;                XSSFCell cell0 = rowi.createCell(0);                XSSFCell cell1 = rowi.createCell(1);                XSSFCell cell2 = rowi.createCell(2);                cell0.setCellValue(keyName);                cell1.setCellValue(keyComment);                cell2.setCellValue(keyType);                columns.append(keyComment);                columns.append(keyName);                columns.append(",");                columns.append(rn);                setCellColor(excel, cell0);                setCellColor(excel, cell2);            }            System.out.println(columns.toString());        } catch (IOException e) {            e.printStackTrace();        } finally {            try {                reader.close();                FileOutputStream f = new FileOutputStream(outPath);                excel.write(f);                f.flush();                f.close();            } catch (IOException e) {                e.printStackTrace();            }        }    }    /**     * @Author Nxy     * @Date 2019/11/14 14:40     * @Param     * @Return     * @Exception     * @Description 初始化需要被特殊标记的字段的集合     */    private static void init() {        greenKeys = new HashSet<String>();        yellowKeys = new HashSet<String>();        greenKeys.add("CERTIFICATE_LEVEL");        greenKeys.add("ATTACHMENT_FILE_1");        greenKeys.add("ATTACHMENT_FILE_2");        greenKeys.add("IS_SIGNED");        greenKeys.add("RETURN_MSG");        greenKeys.add("RETURN_FILE");        greenKeys.add("UPDATE_TIME");        yellowKeys.add("DEPT_ORGANIZE_CODE");        yellowKeys.add("DEPT_NAME");        yellowKeys.add("DISTRICTS_CODE");        yellowKeys.add("DISTRICTS_NAME");        yellowKeys.add("HOLDER_TYPE");        yellowKeys.add("CERTIFICATE_TYPE");        yellowKeys.add("STATE");    }    private static void setCellColor(XSSFWorkbook w, XSSFCell cell) {        if (cell == null) {            return;        }        String v = CurrencyTools.judgeCell(cell);        if (isGreenKey(v)) {            setCellGreen(w, cell);        }        if (isYellowKey(v)) {            setCellYellow(w, cell);        }        if (v.contains("NOT NULL")) {            setcellRed(w, cell);        }    }    /**     * @Author Nxy     * @Date 2019/11/13 16:14     * @Param w:工作簿对象 sheet:工作表对象 headers:表头集合     * @Return void     * @Exception none     * @Description 设置excel表头     */    public static void setHeader(XSSFWorkbook w, XSSFSheet sheet, String[] headers) {        if (sheet == null || headers == null || headers.length == 0) {            return;        }        XSSFRow row0 = sheet.createRow(0);        int length = headers.length;        int i = 0;        for (String header : headers) {            XSSFCell cell = row0.createCell(i);            cell.setCellValue(header);            setCellLightYellow(w, cell);            i++;        }    }    /**    *   @Author Nxy    *   @Date 2019/11/14 14:41    *   @Param    *   @Return    *   @Exception    *   @Description 为cell上色    */    private static void setcolor(XSSFWorkbook w, XSSFCell cell, int r, int g, int b) {        XSSFCellStyle style = w.createCellStyle();        style.setFillPattern(FillPatternType.SOLID_FOREGROUND);        style.setFillForegroundColor(new XSSFColor(new Color(r, g, b)));        cell.setCellStyle(style);    }    private static void setcellRed(XSSFWorkbook w, XSSFCell cell) {        setcolor(w, cell, 231, 102, 100);    }    private static void setCellGreen(XSSFWorkbook w, XSSFCell cell) {        setcolor(w, cell, 135, 200, 107);    }    private static void setCellYellow(XSSFWorkbook w, XSSFCell cell) {        setcolor(w, cell, 255, 209, 114);    }    private static void setCellLightYellow(XSSFWorkbook w, XSSFCell cell) {        setcolor(w, cell, 255, 255, 5);    }    private static boolean isGreenKey(String key) {        return greenKeys.contains(key);    }    private static boolean isYellowKey(String key) {        return yellowKeys.contains(key);    }    /**     * @Author Nxy     * @Date 2019/11/13 12:40     * @Param     * @Return     * @Exception     * @Description 递归截取flag间的字符串，会删除StringBuilder中截取到的部分及flag部分     */    public static void getBetween(StringBuilder source, String startFlag, String endFlag, List<String> result) {        if (source == null || source.length() == 0) {            return;        }        int start = source.indexOf(startFlag);        if (start == -1) {            return;        }        source = source.delete(0, start + 1);        int end = source.indexOf(endFlag);        if (end == -1) {            return;        }        String s = source.substring(0, end);        result.add(s);        source = source.delete(0, end + 1);        getBetween(source, startFlag, endFlag, result);    }    public static void getBefore(StringBuilder source, String flag, List<String> result) {        if (flag == null || source == null || source.length() == 0) {            return;        }        int end = source.indexOf(flag);        if (end == -1) {            return;        }        String re = source.substring(0, end);        result.add(re);    }}