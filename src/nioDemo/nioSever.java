package nioDemo;import javax.sound.sampled.Port;import java.io.IOException;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.channels.SelectionKey;import java.nio.channels.Selector;import java.nio.channels.ServerSocketChannel;import java.nio.channels.SocketChannel;import java.util.Iterator;public class nioSever {    public static void main(String[] args) throws IOException {        server();    }    private static void server() throws IOException {        Selector selector = Selector.open();        ServerSocketChannel severChannel = ServerSocketChannel.open();        severChannel.configureBlocking(false);        severChannel.bind(new InetSocketAddress(8888));        System.out.println("Server start!");        severChannel.register(selector, SelectionKey.OP_ACCEPT);        //select会阻塞，知道有就绪连接写入selectionKeys        while (selector.select() > 0) {            Iterator<SelectionKey> keys = selector.selectedKeys().iterator();            while (keys.hasNext()) {                //SelectionKey为select中记录的就绪请求的数据结构，其中包括了连接所属的socket及就绪的类型                SelectionKey key = keys.next();                if (key.isAcceptable()) {                    SocketChannel socketChannel = severChannel.accept();                    socketChannel.configureBlocking(false);                    socketChannel.register(selector, SelectionKey.OP_READ);                } else if (key.isReadable()) {                    SocketChannel socketChannel = (SocketChannel) key.channel();                    ByteBuffer byteBuffer = ByteBuffer.allocate(2);                    int len = socketChannel.read(byteBuffer);                    byteBuffer.flip();                    if (len != -1&&byteBuffer.remaining()>0) {                        System.out.print(byteBuffer.getChar());                    }                    socketChannel.register(selector, SelectionKey.OP_READ);                }            }        }    }}